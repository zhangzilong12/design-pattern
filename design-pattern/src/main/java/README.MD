#问题
设计一个程序来读取各种不同类型的图片格式，
针对每一种图片格式都设计一个图片读取器，
如GIF图片读取器用于读取GIF格式的图片、JPG图片读取器用于读取JPG格式的图片

#简单工厂模式的实现方法

##几个核心对象：

（1）工厂类，用于创建产品实例
（2）抽象产品类
（3）实际产品类

##分析：
实现了对象的创建和使用分离，对象统一由工厂类创建，客户端不需要关注对象创建的具体逻辑，
只需关注工厂类即可。
但也正是这个原因带来了新的问题，比如对象过多时工厂类逻辑相对复杂，体量比较庞大，过多的if else
影响程序性能和阅读体验等。
另外，每次添加新的对象时，需要修改工厂类，不符合开闭原则。比如再添加PngPicture类，需要
再在工厂类添加了if语句。

##解决方案：
既然我们知道了问题的关键在所有对象都是由唯一的工厂类创建，那么解决起来就容易了。
我们可以对工厂进行抽象化，由其子类负责具体的创建过程。客户端不需要知道具体的产品实现过程，
并且根据抽象工厂进行对象传递，新加对象不需要修改原有代码，只需要新增一个抽象工厂子类而已。
符合开闭原则和依赖倒转原则。

具体实现在FactoryMethod包.

#工厂方法模式下的几个角色：

(1)抽象工厂，抽象工厂可以是接口、抽象类或者具体实现类。用于创建抽象产品类，这里是picture
(2)具体工厂，具体工厂实现或者继承自抽象工厂，用于创建具体的产品，比如gifPicture和jpgPicture
(3)抽象产品，Picture
(4)具体产品：gifPicture和jpgPicture

##分析：
向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，
    甚至无须知道具体产品类的类名。
    在Client类，用户根据factory和picture这2个变量完成了所有工作，而不需要关注我用的是GifPicture的变量还是
    jpgPicture变量。
    
能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂gifFactory的内容

由于工厂方法模式中的每个工厂只生产单一的产品，可能会导致系统中存在大量的工厂类，这会大大的增加系统负担和维护难度。

比如现在我们需要根据颜色添加红色、蓝色这2个颜色的图片。根据工厂方式模式，我们需要创建redFactory和
blueFactory，加上之前的2个，一个就有了4个具体工厂类了。
假设有一个需求，需要将jpg和red的图片归为一类一起处理，gif和blue的图片归为一类一起处理。


#抽象工厂模式：
用一句话概括就是，提供创建一组或者一系列对象的接口

比如之前的图片例子，我们可以按照颜色和格式分为2类，
第一类：red jpg
第二类：blue gif

##几个核心角色：
(1)抽象工厂：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
(2)具体工厂：它实现了在抽象工厂中声明的创建产品的方法
(3)抽象产品：它为每种产品声明接口
(4)具体产品：它定义具体工厂生产的具体产品对象，实现抽象产品接口

抽象工厂CombineFactory声明了2个方法，分别创建BaseColorPicture类和BaseFormatPicture类对象。
然后分别在具体工厂BlueCombineFactory和RedCombineFactory具体实现。
在客户端，具体工厂可以创建一组对象。

##分析：
采用抽象工厂方法，原来需要4个具体工厂类才能干的活，现在用2个具体工厂类就搞定了。
后面如果增加新的组合，比如black和png的组合，只需要新建一BlackCombine即可，符合开闭原则。

但是如果修改了这个组合方式，比如需要修改成颜色，格式和大小的组合，需要大范围的修改代码，
这个是不符合开闭原则的。







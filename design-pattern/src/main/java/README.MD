#问题
设计一个程序来读取各种不同类型的图片格式，
针对每一种图片格式都设计一个图片读取器，
如GIF图片读取器用于读取GIF格式的图片、JPG图片读取器用于读取JPG格式的图片

#简单工厂模式的实现方法

##几个核心对象：

（1）工厂类，用于创建产品实例
（2）抽象产品类
（3）实际产品类

##分析：
实现了对象的创建和使用分离，对象统一由工厂类创建，客户端不需要关注对象创建的具体逻辑，
只需关注工厂类即可。
但也正是这个原因带来了新的问题，比如对象过多时工厂类逻辑相对复杂，体量比较庞大，过多的if else
影响程序性能和阅读体验等。
另外，每次添加新的对象时，需要修改工厂类，不符合开闭原则。比如再添加PngPicture类，需要
再在工厂类添加了if语句。

##解决方案：
既然我们知道了问题的关键在所有对象都是由唯一的工厂类创建，那么解决起来就容易了。
我们可以对工厂进行抽象化，由其子类负责具体的创建过程。客户端不需要知道具体的产品实现过程，
并且根据抽象工厂进行对象传递，新加对象不需要修改原有代码，只需要新增一个抽象工厂子类而已。
符合开闭原则和依赖倒转原则。

具体实现在FactoryMethod包.

##工厂方法模式下的几个角色：

(1)抽象工厂，抽象工厂可以是接口、抽象类或者具体实现类。用于创建抽象产品类，这里是picture
(2)具体工厂，具体工厂实现或者继承自抽象工厂，用于创建具体的产品，比如gifPicture和jpgPicture
(3)抽象产品，Picture
(4)具体产品：gifPicture和jpgPicture

##分析：
(1)向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，
    甚至无须知道具体产品类的类名。
    在Client类，用户根据factory和picture这2个变量完成了所有工作，而不需要关注我用的是GifPicture的变量还是
    jpgPicture变量。
    
(2)能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂gifFactory的内容

##问题
由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销






